use chacha20::cipher::{KeyIvInit, StreamCipher, StreamCipherSeek};
use chacha20::ChaCha20;
use hex_literal::hex;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_ENCRYPT_ELF, GUEST_ENCRYPT_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // FIXME: need a method to gen and pass sym. key around those that need it (pehaps MPC methods)
    let key = [0x42; 32];
    // FIXME: need a good random nonce here!
    let nonce = [0x24; 12];

    // 16 byte test
    let plaintext = hex!("00010203 04050607 08090A0B 0C0D0E0F");
    println!("Plaintext bytes: {:?}", plaintext);

    // Key and IV must be references to the `GenericArray` type.
    // Here we use the `Into` trait to convert arrays into it.
    let mut cipher = ChaCha20::new(&key.into(), &nonce.into());
    // Generate raw keystream bytes
    let mut keystream = [0u8; 16]; // ChaCha20 generates keystream in 64-byte blocks, but this can be any number of bits.
    cipher.apply_keystream(&mut keystream); // keystream XOR with 0s = keystream
    println!("Keystream bytes: {:?}", keystream);

    // zkVM
    let env = ExecutorEnv::builder()
        .write(&plaintext)
        .unwrap()
        .write(&keystream)
        .unwrap()
        .build()
        .unwrap();

    // testing Execution ONLY
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, GUEST_ENCRYPT_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    let mut output: [u8; 16] = receipt.journal.decode().unwrap();
    println!("zkVM output bytes: {:?}", output);

    let ciphertext = hex!("e405626e 4f1236b3 670ee428 332ea20e");
    println!("expected output bytes: {:?}", ciphertext);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(GUEST_ENCRYPT_ID)
        .unwrap();
    println!("Reciept from zkVM OK!");
    
    // ChaCha ciphers support seeking
    cipher.seek(0u32);

    // decrypt ciphertext by applying keystream again
    cipher.apply_keystream(&mut output);
    assert_eq!(output, plaintext);
}
